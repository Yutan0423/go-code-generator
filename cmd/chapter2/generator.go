package main

import (
	"bytes"
	"fmt"
	"go/format"

	"github.com/pkg/errors"
	"golang.org/x/tools/go/packages"
)

type Generator struct {
	pkg string
	typ string
}

func NewGenerator(dir string, typ string) (*Generator, error) {
	pkg, err := packageInfo(dir)
	if err != nil {
		return nil, err
	}

	return &Generator{
		pkg: pkg.Name,
		typ: typ,
	}, nil
}

func packageInfo(dir string) (*packages.Package, error) {
	// 1. パッケージ名を取得するために、指定したディレクトリを静的解析
	pkgs, err := packages.Load(&packages.Config{
		Mode:  packages.NeedName,
		Tests: false,
	}, dir)

	if err != nil {
		return nil, errors.Wrapf(err, "failed to load package dir=%v", dir)
	}
	if len(pkgs) != 1 {
		return nil, errors.Wrapf(err, "%d packages found", len(pkgs))
	}

	return pkgs[0], nil
}

func (g *Generator) Run() ([]byte, error) {
	w := &bytes.Buffer{}

	// 2. fmt.Printfで愚直に生成
	fmt.Fprintf(w, "// Code generated by \"array_helper\"; DO NOT EDIT.\n")
	fmt.Fprintf(w, "\n")
	fmt.Fprintf(w, "package %s\n", g.pkg)
	fmt.Fprintf(w, "\n")

	arrTyp := fmt.Sprintf("%ss", g.typ)
	fmt.Fprintf(w, "\n")
	fmt.Fprintf(w, "func (a %s) Filter(f func(o *%s) bool) %s {\n", arrTyp, g.typ, arrTyp)
	fmt.Fprintf(w, "res := make(%s, 0)\n", arrTyp)
	fmt.Fprintf(w, "for _, o := range a {\n")
	fmt.Fprintf(w, "if f(o) {\n")
	fmt.Fprintf(w, "res = append(res, o)\n")
	fmt.Fprintf(w, "}\n")
	fmt.Fprintf(w, "}\n")
	fmt.Fprintf(w, "return res\n")
	fmt.Fprintf(w, "}\n")

	// 3. formatします
	fmted, err := format.Source(w.Bytes())
	if err != nil {
		return nil, errors.Wrap(err, "failed to format code")
	}

	return fmted, nil
}
